import 'dart:io';
import '../entities/complaint.dart';
import '../entities/complaint_type.dart';
import '../repositories/complaints_repository.dart';
import '../../data/repositories/complaints_repository_impl.dart';

/// Service class to handle complaint-related business logic
class ComplaintService {
  final ComplaintsRepository _repository;

  ComplaintService(this._repository);

  /// Create a new complaint with attachments
  Future<Complaint> createComplaint({
    required String title,
    required String description,
    required String category,
    required String organization,
    required ComplaintType type,
    List<File>? attachments,
  }) async {
    // Handle file uploads (mock)
    final uploadedFiles = attachments != null 
        ? await _uploadFiles(attachments)
        : null;

    // Create complaint
    final complaint = Complaint(
      id: '', // Will be generated by repository
      title: title,
      description: description,
      category: category,
      organization: organization,
      status: 'Open',
      createdAt: DateTime.now(),
      attachments: uploadedFiles,
      type: type,
    );

    return _repository.createComplaint(complaint);
  }

  /// Mock file upload
  Future<List<String>> _uploadFiles(List<File> files) async {
    // Simulate file upload delay
    await Future.delayed(const Duration(seconds: 2));
    
    // Return mock URLs
    return files.map((file) => 
      'https://storage.example.com/${DateTime.now().millisecondsSinceEpoch}_${file.path.split('/').last}'
    ).toList();
  }

  /// Get complaints for the current user
  Future<List<Complaint>> getUserComplaints() async {
    final complaints = await _repository.getComplaints();
    // In a real app, we would filter by user ID
    return complaints;
  }

  /// Search organizations
  Future<List<Map<String, dynamic>>> searchOrganizations(String query) async {
    if (_repository is ComplaintsRepositoryImpl) {
      return (_repository as ComplaintsRepositoryImpl).searchOrganizations(query);
    }
    return [];
  }

  /// Searches complaints based on given criteria
  /// 
  /// [query] - Search term to match against title and description
  /// [category] - Optional category filter
  /// [status] - Optional status filter
  /// [startDate] - Optional start date for date range filter
  /// [endDate] - Optional end date for date range filter
  Future<List<Complaint>> searchComplaints({
    required String query,
    String? category,
    String? status,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    final complaints = await _repository.getComplaints();
    
    return complaints.where((complaint) {
      // Match search query
      final matchesQuery = query.isEmpty ||
          complaint.title.toLowerCase().contains(query.toLowerCase()) ||
          complaint.description.toLowerCase().contains(query.toLowerCase()) ||
          complaint.organization.toLowerCase().contains(query.toLowerCase());

      // Match category filter
      final matchesCategory = category == null || complaint.category == category;

      // Match status filter
      final matchesStatus = status == null || complaint.status == status;

      // Match date range
      final matchesDateRange = (startDate == null || complaint.createdAt.isAfter(startDate)) &&
          (endDate == null || complaint.createdAt.isBefore(endDate.add(const Duration(days: 1))));

      return matchesQuery && matchesCategory && matchesStatus && matchesDateRange;
    }).toList();
  }

  /// Gets complaints by category
  Future<List<Complaint>> getComplaintsByCategory(String category) async {
    final complaints = await _repository.getComplaints();
    return complaints.where((c) => c.category == category).toList();
  }

  /// Gets complaints by organization
  Future<List<Complaint>> getComplaintsByOrganization(String organization) async {
    final complaints = await _repository.getComplaints();
    return complaints.where((c) => c.organization == organization).toList();
  }
} 